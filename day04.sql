-- ABS()
-- 절대값을 반환한다.
SELECT -10,ABS(-10) FROM DUAL;

-- ROUND()
-- 반올림
SELECT ROUND(1234.567 , 1), ROUND(1234.567,-1),ROUND(1234.567) FROM DUAL;

-- FLOOR()
-- 주어진 숫자보다 작거나 같은 정수중 최대값을 반환한다.
SELECT FLOOR(2), FLOOR(2.1) FROM DUAL; 

-- TRUNC()
-- 버림
SELECT TRUNC(1234.567,1),TRUNC(1234.567,-1),TRUNC(1234,567) FROM DUAL;

-- CEIL()
-- 올림
SELECT CEIL(2),CEIL(2.1) FROM DUAL;

-- MOD()
-- 나누기 후 나머지를 반환
SELECT MOD(1,3), MOD(2,3), MOD(3,3), MOD(4,3), MOD(0,3) FROM DUAL;

-- POWER()
-- 주어진 숫자의 지정된 수 만큼 제곱한다.
SELECT POWER(2,1),POWER(2,2),POWER(2,3),POWER(2,0) FROM DUAL;

-- 사원테이블에서 사원 번호가 짝수인 사람은 0 홀수인 사람은 1 을	사원번호 연산결과
SELECT EMPLOYEE_ID,MOD(EMPLOYEE_ID,2) FROM EMPLOYEES;

-- 사원번호가 짝수인 ㅅ ㅏ람들의 사원번호와 이름을 조회하세요
SELECT e.EMPLOYEE_ID,e.FIRST_NAME FROM EMPLOYEES e
WHERE MOD(EMPLOYEE_ID,2) = 0
ORDER BY e.employee_id;

-- 사원테이블에서 이름 , 급여, 급여의 1000 당 네모로 채워 조회
SELECT first_name, salary, RPAD('■',ROUND(SALARY / 1000),'■') FROM EMPLOYEES;

-- 날짜 함ㄴ수
-- 날짜끼리의 연산은 안됨
-- SYSDATE : 현재 날짜를 반환

-- ADD_MONTH() 특정 날짜의 개월수를 더한 날을 반환한다.
SELECT SYSDATE, ADD_MONTHS(SYSDATE,2) FROM DUAL;

-- MONTH_BETWEEN()
-- 두 날짜 사이의 개월수를 반환
SELECT SYSDATE, HIRE_DATE, MONTHS_BETWEEN(SYSDATE,HIRE_DATE) FROM EMPLOYEES e;

-- NEXT_DAY()
-- 주어진 날짜 다음에 나타나는 지정요일(1: 일요일 ~ 7: 토요일)
SELECT SYSDATE, NEXT_DAY(SYSDATE,1) FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE,'일') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE,'일요일') FROM DUAL;

-- 사원 테이블에서 모든 사원의 입사일로부터 6개월 뒤의 날짜를
-- 이름, 입사일, 6개월 뒤의 날짜순으로 출력
SELECT FIRST_NAME, HIRE_DATE,ADD_MONTHS(HIRE_DATE,6) FROM EMPLOYEES e ;

-- 사원이 120번인 사원이 입사후 3년 6개월 뒤 진급예정이다 이름, 진급날짜를 조회
SELECT FIRST_NAME,ADD_MONTHS(HIRE_DATE,42) FROM EMPLOYEES e
WHERE EMPLOYEE_ID = 120;

SELECT FIRST_NAME,MONTHS_BETWEEN(SYSDATE,HIRE_DATE) FROM EMPLOYEES e ;

SELECT FIRST_NAME, HIRE_DATE,TRUNC(MONTHS_BETWEEN(SYSDATE,HIRE_DATE),1) FROM EMPLOYEES e
WHERE MONTHS_BETWEEN(SYSDATE,HIRE_DATE) >= 200;

-- 형변환 함수
-- TO_CHAR()
-- 날짜를 형식에 맞춰 문자열로 변환
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD'),
TO_CHAR(SYSDATE,'YYYY-MM-DD DAY'),
TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MI:SS')
FROM DUAL;

-- 날짜 포멧형식
-- SCC, CC : 서기
-- YYYY, YY : 년도
-- MM 월 DD 일 DAY요일 
-- MON : 월명(JAN)
-- MONTH : 월명(JANUARY)
-- HH, HH24 : 시간
-- MI 분 SS 초

--숫자 포멧
-- 0 : 숫자 공백시 0으로 채움
-- 9 : 숫자
-- , : ,
-- L : 지역 통화


SELECT TO_CHAR(1234567,'9,999,999') FROM DUAL;
SELECT TO_CHAR(1234567,'L9,999,999') FROM DUAL;
SELECT TO_CHAR(12,'0999') FROM DUAL;

--TO_DATE()
SELECT TO_DATE('2024.08.27') FROM DUAL;
SELECT TO_DATE('08.27.2024', 'MM,DD,YYYY') FROM DUAL;
SELECT TO_DATE('2024.08', 'YYYY.MM') FROM DUAL; -- 일 입력하지 않으면 자동으로 1일이 나옴
SELECT TO_DATE('11','DD')FROM DUAL;

-- NULL 처리함수
-- NULL 값을 다른 값으로 변경
-- NVL()
SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,COMMISSION_PCT
FROM EMPLOYEES WHERE COMMISSION_PCT IS NULL;

SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,NVL(COMMISSION_PCT,0)
FROM EMPLOYEES WHERE COMMISSION_PCT IS NULL;

-- NVL2()
-- NULL 일때 치환할 값, NULL이 아닐 때 치환할 값
SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,NVL2(COMMISSION_PCT,1,0)
FROM EMPLOYEES e ;

-- 순위 함수
-- RANK() OVER() 
-- 그룹 내 순위를 계산하여 NUMBER 타입으로 순위를 반환
SELECT RANK() OVER(ORDER BY SALARY DESC), FIRST_NAME, SALARY FROM EMPLOYEES;

-- DENSE_RANK()
SELECT DENSE_RANK() OVER(ORDER BY SALARY DESC), FIRST_NAME,SALARY
FROM EMPLOYEES e ;

-- 집계함수
-- 여러 행 들의 대한 연산 결과를 하나의 행으로 반환
-- 집계함수는 NULL을 체크하지 않는다.
-- 평균을 구할 때 내가 원하는 값과는 다른 결과가 나올수있다.

-- COUNT() 행의 개수를 세서 반환
SELECT COUNT(*) FROM EMPLOYEES e ;

-- MIN() 최소값 구하기
SELECT MIN(SALARY) FROM EMPLOYEES e ;

-- MAX() 최대값 구하기
SELECT MAX(SALARY) FROM EMPLOYEES e ;

-- AVG() 평균 구하기
SELECT AVG(SALARY) FROM EMPLOYEES e ;

-- SUM() 총합 구하기
SELECT SUM(SALARY) FROM EMPLOYEES e ;

--사원테이블에서 보너스를 받는 사원의 수를 조회
SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES e; 
-- 직종이 SA_REP 인 사원들의 평균 급여 최고급여 최저급여 급여의 총합 조회
SELECT AVG(SALARY),MAX(SALARY),MIN(SALARY),SUM(SALARY)FROM EMPLOYEES e 
WHERE JOB_ID = 'SA_REP';
--3
SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM EMPLOYEES e ;
--4
SELECT ROUND(AVG(SALARY),1) FROM EMPLOYEES e
WHERE DEPARTMENT_ID = 80;

-- GROUP BY(그룹화)
-- 특정 테이블에서 소그룹을 만들어 결과를 분산시켜 얻고자 할 때
-- GROUP BY : ~별(EX 부서별 인원수)

-- 각 부서별 급여의 평균과 총합을 출력하세요
SELECT DEPARTMENT_ID ,AVG(SALARY), SUM(SALARY) FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ;

-- 부서별, 직종별로 그룹을 나눠 인원수를 출력하되, 부서번호가 낮은 순으로 정렬하세요
SELECT DEPARTMENT_ID,JOB_ID, COUNT(*) FROM EMPLOYEES e
GROUP BY DEPARTMENT_ID , JOB_ID 
ORDER BY DEPARTMENT_ID ;

-- 각 직종별 인워수
SELECT JOB_ID,COUNT(*) FROM EMPLOYEES e
GROUP BY JOB_ID;

-- 각 직종별 급여의 합
SELECT JOB_ID, SUM(SALARY) FROM EMPLOYEES e
GROUP BY JOB_ID ;
-- 부서별로 가장 높은 급여
SELECT DEPARTMENT_ID,MAX(SALARY) FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID ;
-- 부서별 급여의 합계를 내림차순
SELECT DEPARTMENT_ID,SUM(SALARY) FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID DESC;


CREATE TABLE 월별매출 (
    상품ID VARCHAR2(5),
    월 VARCHAR2(10),
    회사 VARCHAR2(10),
    매출액 INTEGER );
    
INSERT INTO  월별매출 VALUES ('P001', '2019.10', '삼성', 15000);
INSERT INTO  월별매출 VALUES ('P001', '2019.11', '삼성', 25000);
INSERT INTO  월별매출 VALUES ('P002', '2019.10', 'LG', 10000);
INSERT INTO  월별매출 VALUES ('P002', '2019.11', 'LG', 20000);
INSERT INTO  월별매출 VALUES ('P003', '2019.10', '애플', 15000);
INSERT INTO  월별매출 VALUES ('P003', '2019.11', '애플', 10000);

SELECT * FROM 월별매출;

-- ROLLUP()
-- 소그룹간의 합계를 계산하는 함수
SELECT 상품ID, 월, SUM(매출액) FROM 월별매출
GROUP BY ROLLUP(상품ID,월);

-- CUBE()
-- 항목들 간의 다차원적인 소계
-- GROUP BY 절에 명시한 모든 컬럼에 대해 소그룹 합계를 계산해준다.
SELECT 상품ID, 월, SUM(매출액) FROM 월별매출
GROUP BY CUBE(상품ID, 월);

-- GROUPING SETS
-- 특정 항목에 대한 소계를 내는 함수
SELECT 상품ID, 월, SUM(매출액) FROM 월별매출
GROUP BY GROUPING SETS(상품ID, 월);

--각 부서의 최대급여, 최소급여, 인원수를 출력하되, 급여의 합이 8000이상인 결과만 조회할 것
SELECT DEPARTMENT_ID ,MAX(SALARY),MIN(SALARY), COUNT(*) FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID 
HAVING SUM(SALARY) >= 8000; 

-- 각 부서별 인원수가 20명 이상인 부서의 정보를 부서번호 급여의합 급여의 평균 인원 수
SELECT DEPARTMENT_ID,SUM(SALARY),ROUND(AVG(SALARY),1),COUNT(*) FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID 
HAVING COUNT(*) >= 20; 

-- 부서별, 직종별로 그룹화 하여 결과를 부서번호,ㅡ 직종 인원수 순으로 출력 직종이 MAN 으로 끝나ㅑ는경우
SELECT DEPARTMENT_ID,JOB_ID,COUNT(*) FROM EMPLOYEES e 
WHERE JOB_ID LIKE '%MAN'
GROUP BY(DEPARTMENT_ID,JOB_ID);

-- 각 부서별 평균 급여를 ㅅ ㅗ수점 한자리까지 버림으로 조회 평균급여 1만 미만 그룹만 조회,부서번호가 50번이하인 부서만 조회
SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY),1) FROM EMPLOYEES e 
WHERE DEPARTMENT_ID <= 50
GROUP BY DEPARTMENT_ID 
HAVING AVG(SALARY) < 10000;

-- 각 부서별 부서번호, 급여의 합 , 평균, 인원수 순으로 출력 급여의 합 30000 이상인 경우 출력, 급여의 평균 소수점 둘째자리 반올림
SELECT DEPARTMENT_ID, SUM(SALARY), ROUND(AVG(SALARY),1), COUNT(*) FROM EMPLOYEES e  
GROUP BY DEPARTMENT_ID 
HAVING SUM(SALARY) >= 30000; 

CREATE TABLE TEST001(
	ID VARCHAR2(20) PRIMARY KEY,
	PW VARCHAR2(10),
	AGE NUMBER
	);
	
SELECT * FROM TEST001;

SELECT * FROM ALL_INDEXES WHERE TABLE_NAME = 'EMPLOYEES';

SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Michael' AND JOB_ID  = 'MK_MAN';

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES e 
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Michael' AND JOB_ID  = 'MK_MAN');

-- 사원번호가 150번인 사원의 급여와 같은 급여를 받는 사원들의 정보를
-- 사번, 이름, 급여순으로 출력하세요

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES e 
WHERE SALARY =(SELECT SALARY FROM EMPLOYEES e2 WHERE EMPLOYEE_ID = 150);

-- 급여가 회사전체 평균급여 이상인 사람들의 이름과 급여조회하기
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES e 
WHERE SALARY >= ( SELECT AVG(SALARY) FROM EMPLOYEES e2);  

-- 사번이 111번인 사원의 직종과 같고, 사번이 159번인 사원의 급여ㅑ보다 많이 받는 사원들의 정보를 사번 이름 직종 급여순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES e 
WHERE JOB_ID =(SELECT JOB_ID FROM EMPLOYEES e2 WHERE EMPLOYEE_ID = 111 ) 
AND SALARY >(SELECT SALARY FROM EMPLOYEES e3 WHERE EMPLOYEE_ID = 159);